\documentclass[8pt]{extarticle}
 
%% \usepackage[fleqn]{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsfonts,amsthm,bm}
\usepackage{breqn}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[ruled,vlined,linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{subcaption}
%% \usepackage{datetime}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{mathrsfs}
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{parskip} %turns off paragraph indent
\pagestyle{fancy}

\usepackage{xcolor}
\usepackage{mdframed}

\usepackage[small]{titlesec}

\usepackage{hanging}

\usetikzlibrary{arrows}

\DeclareMathOperator*{\argmin}{argmin}
\newcommand*{\argminl}{\argmin\limits}

\newcommand{\mathleft}{\@fleqntrue\@mathmargin0pt}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}} 
\newcommand{\N}{\mathbb{N}}
\newcommand{\ppartial}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\p}{\partial}
\newcommand{\te}[1]{\text{#1 }}
\newcommand{\norm}[1]{\|#1\|}

\setcounter{MaxMatrixCols}{20}

% remove excess vertical space for align equations
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{0pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{0pt}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

% \newtheorem{mdtheorem}{Theorem}
% \newenvironment{theorem}
% {\begin{mdframed}[
%   backgroundcolor=green!10,
%   topline=false,
%   rightline=false,
%   bottomline=false,
%   leftline=false
%   ]\begin{mdtheorem}}
%     {\end{mdtheorem}\end{mdframed}}

\begin {document}

\lhead{Notes - Tensor/Array Manipulations, Bill (Yuan) Liu}

% \begin{align}
%   \nabla f_{k+1}^T p_k & \geq c_2 \nabla f_k^T p_k\\
%   \frac{\partial \phi(\alpha_k)}{\partial \alpha_k} & \geq \frac{\partial \phi(0)}{\partial \alpha_k}\\
%   &c_1,\alpha_k \in (0,1)\\
%   &0<c_1<c_2<1
% \end{align}
  
\begin{multicols*}{2}
    
  \section{Basic Concurrency Primitives, Ch1}
  topics: interior mutability, threadsafety, runtime borrow check

  \subsection{single thread interior mutability}
  RefCell: borrow at runtime\\
  Cell: value replacement, not borrow; limited to word size
  
  \subsection{threadsafe interior mutability}
  Mutex: exclusive borrow at runtime\\
  RwLock: differentiates borrow type: exclusive vs. shared read only\\
  Atomics: value replacement, not borrow; limited to word size\\

  UnsafeCell: express raw pointer to wrapped data via unsafe block; in practice wrapped by a safer interface to user\\

  Traits for threadsafety: Send, Sync\\
  T: Send $\iff$ T can be transferred to another thread\\
  T: Sync $\iff$ T can be shared with $>1$ threads; \&T: Send\\
  all primitve types are Send + Sync\\
  
  auto traits:
  \begin{itemize}
  \item automatically opt-in
  \item manually opt-out
  \item recursively deduced on filds of structs
  \end{itemize}

  un-implemented types:
  \begin{verbatim}
  Cell<T>: Send + Sync!
  * const T / * mut T: !Send + !Sync
  Rc<T>: !Send + !Sync
  std::marker::PhantomdData<T> where T: !Send / !Sync
  \end{verbatim}
  
  force opt-in for un-implemented type:
  \begin{verbatim}
  unsafe impl Send/Sync for T {}
  \end{verbatim}
  
  \vfill\null
  \columnbreak
  
  \subsection{Mutex}

  T is usually Send(not required) in which case the Mutex gives Sync:\\
  T: Send $\implies$ \verb%Mutex<T>: Sync%

  logical states: unlocked, locked

  owning wrapper over T

  interface makes access to T safer
  
  MutexGuard as proof of exclusive access; drop automatically triggers unlock at the end of its lifetime

  efficient usage: make locked interval as short as possible

  lock poisoning: when thread panics while holding the lock
  \begin{itemize}
  \item lock is released
  \item the invoking method call errors
  \item further invoking a poisoned mutex returns error and also a locked MutexGuard in case user can correct it to some consistent state
  \end{itemize}

  unnamed guard may not be immediately dropped in certain statements:
\begin{verbatim}
if ... /*dropped here; only boolean value needed*/ {
  ...
}
\end{verbatim}

\begin{verbatim}
if let ... = ... {
  ... /*dropped here; may borrow from let expression*/
}
\end{verbatim}
  
  \subsection{ReaderWriterLock}

  requires T: Send + Sync:\\
  T: Send + Sync $\implies$ \verb%RwLock<T>: Send + Sync%

  logical staes: unlcoked, locked by 1 exclusive accessor, locked by any number of shared readers

  differentiating lock guards:\\
  read() $\implies$ ReLockReadGuard: Deref\\
  write() $\implies$ ReLockWriteGuard: DerefMut

  writer starvation issue to cosider for fairness of access

  \subsection{Thread Signaling}

  \subsection{park/unpark}
  park: current thread put itself to sleep\\
  unpark: another thread wakes sleeping thread; needs handle of the sleep read from spawn() method or thread::current()

  spurious wakeup due to false sharing, etc. $\implies$ user provide a check upon wakeup

  request to unpark recorded if unpark happens before park in order to  avoid lost notification, but does not stack up (max of 1 unpark recorded)

  \vfill\null
  \columnbreak
    
  \subsection{Condition Variable}

  signaling events related ro protected data of mutex

  methods: wait, notify

  atomically unlock mutex and start waiting (to avoid lost notification)

  \subsubsection{Communication}
  waiting thread:\\
  takes MutexGuard as input
  unlocks mutex
  thread put to sleep
  thread wakes (via a notify of CondVar or spurious wakeup)
  relocks mutex and returns MutexGuard

  notifying thread:\\
  invoke notify on CondVar

  \subsubsection{Spurious Wakeup}
  need additional memory to check actual event: can add this along with the original value wrapped by mutex\\
  use a loop with wait to put thread back to sleep if condition not met
  
  usage: 1 CondVar for 1 mutex

  optionally can wait with timeout parameter to unconditionally wakeup thread after timeout

  \subsection{Comparison of Interior Mutability Primitives}
  \begin{tabular}{| c | c | c |}
    \hline
    & value replacement & reference / borrow \\
    \hline
    1  thread & Cell & RefCell \\
    \hline
    threadsafe & Atomic & Mutex/RwLock \\
    \hline
  \end{tabular}

  \subsection{Comparison of Shared Ownership Primitives}
  Rc/Arc: act similar to Box / smart pointer but with dropping logic to take care of deallocation for shared data\\
  
  \begin{tabular}{| c | c |}
    \hline
    1  thread & Rc \\
    \hline
    threadsafe & Arc \\
    \hline
  \end{tabular}
  
  \subsection{Traits for Interior Mutability Primitives}

  \verb%T: Send% $\implies$ \verb%Cell<T>: Send + !Sync% (usual practical case)\\
  \verb%T: !Send% $\implies$ \verb%Cell<T>: !Send + !Sync%\\
  \verb%T: Send% $\implies$ \verb%RefCell<T>: Send + !Sync% (usual)\\
  \verb%T: !Send% $\implies$ \verb%RefCell<T>: !Send + !Sync%\\
  \verb%T: Send% $\implies$ \verb%Mutex<T>: Send + Sync% (usual)\\
  \verb%T: !Send% $\implies$ \verb%Mutex<T>: !Send + !Sync%\\
  \verb%T: Send + Sync% $\implies$ \verb%RwLock<T>: Send + Sync% (usual)\\
  \verb%T: !Send / !Sync% $\implies$ \verb%RwLock<T>: !Send + !Sync%\\

  \subsection{Traits for Shared Ownership Primitives}
  \verb%Rc<T>: !Send + !Sync%\\
  \verb%T: Send + Sync% $\implies$ \verb%Arc<T>: Send + Sync%\\

  \vfill\null
  \columnbreak
  
  \subsection{Typical Usage Pattern}
  \verb%Arc<Mutex<T>>%\\
  where:\\
  Arc allows threadsafe immutable sharing\\
  Mutex allows interior mutability using references across $\geq1$ threads

  \verb%Rc<RefCell<T>>%\\
  where:\\
  Rc allows single thread immutable sharing\\
  RefCell allows interior mutability using references in single thread

  \verb%Rc<Cell<T>>%\\
  where:\\
  Rc allows single thread immutable sharing\\
  Cell allows interior mutability using value in single thread

  \verb%Arc<Atomic<T>>%\\
  where:\\
  Arc allows threadsafe immutable sharing\\
  Atomic allows interior mutability using value across $\geq1$ threads

  \vfill\null
  \columnbreak

  \section{Atomics}

  \verb%fetch_and_modify%\\
  \verb%swap%\\
  \verb%compare_exchange%:
  \begin{itemize}
    \item ABA problem for pointer algorithms
    \item weak version exists for more efficient impl. on some hardware at expense of spurious wakeup
    \end{itemize}
  \verb%fetch_update% $\iff$ load followed by loop with \verb%compare_exchange_weak% and user provided computation
  
  \subsection{Scoped Thread}

  regular \verb%std::thread::spawn% requires closure to be Send $\implies$ all captures of closure are required to be Send
  
  \verb%std::thread::scope%:\\
  borrows object of non-static lifetime that can outlive thread\\
  muatiblity rules apply\\
  threads are automatically joined at the end of the scope

  \subsection{Lazy Initialization}
  execute once by 1 thread, sharable afterwards\\
  race possible from threads, but this is different from data race which causes undefined behaviour (UB)\\
  can use \verb%CondVar% / thread parking / \verb%std::sync::Once% / \verb%std::sync::OnceLock% to avoid wasted compute from multiple threads

  \subsection{Move Closure}
  transfer ownership of value\\
  capture variable via copying/moving instead of borrowing\\
  copying reference in a move closure in order to borrow from variable\\
  note: Atomic does not implement Copy trait

  \subsection{Data Sharing Between Threads in General}
  data shared need to outlive all involved threads:\\
  \begin{itemize}
    \item make data owned by entire program via static lifetime (static item exists even before start of the main program
    \item leak an allocation and promise never to drop it from that point onward in the duration of the entire program:
      eg: \verb%Box::leak(Box::new(..))%\\
      note: \verb%'static% means the object will exist until the end of the program but may not exist at the start of the program\\
      note: Copy $implies$ when moved, the original value still exists
    \item reference counting: track ownership and drop when no owners\\
      eg: \verb%std::rc::Rc%: clone increments counter only and gives reference to allocation\\
      eg: \verb%std::sync::Arc%: version of $Rc$ that is safe between threads\\
    \end{itemize}

    use of scope and variable shadowing to reuse identifiers when cloning:\\
    shadowing: original name is not obtainable anymore in current scope\\
    original name still obtainable in an outerscope, can clone it in another inner scope

    reference counted pointers(\verb%Rc% and \verb%Arc%) have same restrictions as immutable reference (\verb%&T%)

    mutable borrows are guaranteed at compile time $\implies$ mutable aliasing between 2 variables does not occur; optimization to remove impossible code blocks possible

    assumptions held by the compiler:
    \begin{itemize}
      \item  an immutable reference exists $implies$ no other mutable references to the associated data exists
      \item there is at maximum 1 mutable reference to an object at anytime
    \end{itemize}
      
    if such assumptions are broken, then UB exists: more wrong conclusions may be propagated through optimizations

    \verb%unsafe% blocks are also assumed to be sound by the compiler which means compiler may apply optimizations and elide code when feasible

    \subsection{Interior Mutability}

    shared reference \verb%&T%: copied and sharable (not mutable)\\
    exclusive reference \verb%& mut T%: exclusive borrow of T

    interior mutability provides more flexibility for shared data that needs mutation

    \verb%Cell / Atomic%: replace value, no borrow\\
    \verb%RefCell / Mutex%: runtime borrowing; book-keeping cost for existing borrows; failable at runtime

    \vfill\null
    \columnbreak
    
    \section{Memory Ordering}
    defining happens-before relations across threads

    concurrent non-atomic stores to same variable causes data race $\implies$ UB

    lack of globally consistent order

    thread spawn/join: automatically enforces happens-before relation

    \subsubsection{Relaxed Ordering}

    \begin{itemize}
    \item per atomic variable: a total modification order in every run of the program $\implies$ all modifications of the said atomic variable happen in 1 order that is consistent/same from views of every thread
    \item multiple possible orderings may exist when the program is run multiple times, but each run satisfies a total modification order
    \item no happens-before relation
    \end{itemize}

    \subsubsection{Release-Acquire Ordering Pair}
    pairing:\\
    store operation specified with release semantics\\
    load operation specified with acquire semantics

    happens-before relation formed at runtime when load succeeds: all memory operations before release store is observable by and after acquire load

    release store of an atomic variable may be modified by any number of fetch-modify / compare-exchange operations and still have a happens-before relation with an acquire load afterwards on the said atomic variable

    any store of the associated atomic variable breaks the chain of a release-acquire pair (that previously starts with a release store and possibly followed with fetch-modifies/compare-exchanges)

    use of non-atomic variable in different threads and borrow checker $\implies$ may need unsafe blocks
    
    \subsubsection{Release-Consume Ordering Pair}

    pairing:\\
    store operation specified with release semantics\\
    load operation specified with consume semantics

    happens-before relation for associated atomic variable in the release store and the dependent expressions in the consumer thread

    practically, hard to define dependent evaluation and implementation tends to fallback to acquire semantics instead
    
    \subsubsection{Sequentially Consistent Ordering}

    pairing:\\
    store operation specified with SeqCst semantics\\
    load operation specified with SeqCst semantics

    guarantees of:
    \begin{itemize}
    \item acquire ordering
    \item release ordering
    \item globally consistent ordering of all SeqCst operations (every SeqCst operation in a program is a part of a single total order that all threads agree on)
    \end{itemize}

    can replace acquire and release ordering and maintain happens-before relation
    
    \subsection{Memory Fence}

    separate memory ordering semantics from atomic operations

    it can take place of acquire / release / other memory order operations

    types of fences:
    \begin{itemize}
    \item release fence
    \item acquire fence
    \item acquire-release fence
    \item sequentially consistent fence
    \end{itemize}
      
    \subsubsection{Practical Replacement}
    
    \begin{tabular}{| c | p{50mm} |}
    \hline
    \textbf{without fences} & \textbf{with fences} \\
    \hline
    release store & fence with release ordering \newline ... \newline atomic store (any memory ordering) &
    \hline
    acquire lead & atomic load (any memory ordering) \newline ... \newline fence with acquire ordering &
    \hline
    \end{tabular}

    any atomic store following release fence is observable by any atomic load before acquire fence $\implies$ happens-before relation is established between the release-acquire fences pairing

    practical usages:
    \begin{itemize}
    \item can be used for multiple variables at once
    \item conditional fence (apply happens-before relation only after certain condition is met)\\
      eg: place acquire fence in conditional branch that succeeds that is relevant to the atomic variable
    \item may be more efficient if atomic variable is expected to fail in comparison often (let atomic variable be loaded with relaxed memory ordering)
    \end{itemize}
  
    \subsection{Compiler Fence}

    \subsection{FAQs}

    \subsection{Summary}
    
    
\end{multicols*}

\end {document}
